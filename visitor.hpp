/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

#ifndef VISITOR_HPP
#define VISITOR_HPP

/**
 * @file
 * @author Ennio Barbaro
 * @date 18 Jan 2015
 * @brief Implements the function \ref apply_visitor
 */

#include <utility>
#include <type_traits>

#include "variant_storage.hpp"

template<class ... Types>
class variant;

template<class Callable, class T>
class curried_t
{
public:
    curried_t( Callable && f, T && value ) 
        noexcept( detail::and_<
            std::is_nothrow_constructible<Callable, Callable &&>,
            std::is_nothrow_constructible<T, T&&> >::value ) :
        f( std::forward<Callable>(f) ),
        value( std::forward<T>(value) )
    {}
    
    template<class ... Args>
    std::result_of_t< Callable&( T&, Args&& ... )> operator()(Args && ... args) &
        noexcept( 
            noexcept( std::declval<Callable&>() ( std::declval<T&>(), std::declval<Args&&>() ... ) 
            ) 
        )
    {
        return std::forward<Callable&>(f)( std::forward<T&>(value),  std::forward<Args>(args) ... );
    }
    
    template<class ... Args>
    std::result_of_t< Callable&&( T&&, Args&& ... )> operator()(Args && ... args) &&
        noexcept( 
            noexcept( std::declval<Callable&&>() ( std::declval<T&&>(), std::declval<Args&&>() ... ) 
            ) 
        )
    {
        return std::forward<Callable&&>(f)( std::forward<T&&>(value),  std::forward<Args>(args) ... );
    }
    
    template<class ... Args>
    std::result_of_t< Callable&( T&, Args&& ... )> operator()(Args && ... args) const &
        noexcept( 
            noexcept( std::declval<Callable const &>() ( std::declval<T const &>(), std::declval<Args&&>() ... ) 
            ) 
        )
    {
        return std::forward<Callable const &>(f)( std::forward<T const &>(value),  std::forward<Args>(args) ... );
    }

private:
    Callable f;
    T value;
};

/**
 * @brief Compute the result type of a visit
 */
template<class Callable, class ... Args>
struct result_of_visit;

template<class Callable, class ... Args>
using result_of_visit_t = typename result_of_visit<Callable, Args ...>::type;

/**
 * @brief Determine if a visit operation might throw.
 */
template<class Callable, class ... Args>
struct is_nothrow_visitable;

#ifndef VARIANT_IN_DOXYGEN_PARSING

template<class Callable>
struct result_of_visit<Callable>
{
    typedef std::result_of_t< Callable() > type;
};

template<class Callable, class ... Args, class ... Tail>
struct result_of_visit< Callable, variant<Args...> &, Tail ... >
{
    typedef std::common_type_t<
        typename result_of_visit< Callable, Args&, Tail ... >::type ...
    > type;
};

template<class Callable, class ... Args, class ... Tail>
struct result_of_visit< Callable, variant<Args...> &&, Tail ... >
{
    typedef std::common_type_t<
        typename result_of_visit< Callable, Args&&, Tail ... >::type ...
    > type;
};

template<class Callable, class ... Args, class ... Tail>
struct result_of_visit< Callable, variant<Args...> const &, Tail ... >
{
    typedef std::common_type_t<
        typename result_of_visit< Callable, Args const &, Tail ... >::type ...
    > type;
};

template<class Callable, class Head, class ... Tail>
struct result_of_visit< Callable, Head, Tail ... > :
    result_of_visit< curried_t<Callable, Head>, Tail ... > {};


template<class Callable>
struct is_nothrow_visitable<Callable> :
    std::integral_constant<
        bool,
        noexcept( std::declval<Callable>()() )
    > {};

template<class Callable, class Head, class ... Tail>
struct is_nothrow_visitable<Callable, Head, Tail ... > :
    is_nothrow_visitable< curried_t<Callable, Head>, Tail ... > {};
    
template<class Callable, class ... Args, class ... Tail>
struct is_nothrow_visitable<Callable, variant<Args... > &, Tail ... > :
    detail::and_<
        is_nothrow_visitable<
            Callable,
            Args&,
            Tail ... > ... > {};

template<class Callable, class ... Args, class ... Tail>
struct is_nothrow_visitable<Callable, variant<Args... > &&, Tail ...> :
    detail::and_<
        is_nothrow_visitable<
            Callable,
            Args&&,
            Tail ... > ... > {};

template<class Callable, class ... Args, class ... Tail>
struct is_nothrow_visitable<Callable, variant<Args... > const &, Tail ...> :
    detail::and_<
        is_nothrow_visitable<
            Callable,
            Args const &,
            Tail ... > ... > {};

#endif //VARIANT_IN_DOXYGEN_PARSING

/**
 * @brief Calls the provided \p Callable with the given \p Args, replacing the \ref variant args with the actual type.
 * @tparam Callable Must be a function object that can accept all the possible combination of the variant types provided in \p Args
 * 
 * Example:
 * \code{cpp}
 * 
 * apply_visitor(f, variant<int,string>(32) ); //Calls f(32);
 * apply_visitor(f, variant<int,string>("h"), 5); // Calls f("h", 5);
 * apply_visitor(f, 12, variant<int,string>("g"), variant<double,string>(32.4)); //Calls f(12, "g", 32.4 );
 * 
 * \endcode
 */
template<class Callable, class ... Args>
result_of_visit_t<Callable&&, Args&& ...> apply_visitor(Callable && c, Args && ... args)
    noexcept( is_nothrow_visitable<Callable &&, Args && ...>::value );

template<class Callable>
result_of_visit_t<Callable&&> apply_visitor(Callable && c)
    noexcept( is_nothrow_visitable<Callable&&>::value )
{
    return std::forward<Callable>(c)();
}

template<class Callable, class Head, class ... Tail>
result_of_visit_t<Callable&&, Head&&, Tail&& ...> apply_visitor(Callable && c, Head && head, Tail && ... tail)
    noexcept( is_nothrow_visitable<Callable &&, Head &&, Tail && ...>::value )
{
    return apply_visitor(
        [&](auto && ... args)
        {
            return std::forward<Callable>(c)( std::forward<Head>(head), std::forward<decltype(args)>(args) ... );
        },
        std::forward<Tail>(tail) ... );
}

template<class Callable, class ... Args, class ... Tail>
result_of_visit_t<Callable&&, variant<Args...> &, Tail&& ...> apply_visitor(Callable && c, variant<Args...> & head, Tail && ... tail)
    noexcept( is_nothrow_visitable<Callable&&, variant<Args...> &, Tail && ... >::value )
{
    return invoke(
        [&](auto & val)
        {
            return apply_visitor( std::forward<Callable>(c), val, std::forward<Tail>(tail) ... );
        },
        head.get_storage(),
        head.which() );
}

template<class Callable, class ... Args, class ... Tail>
result_of_visit_t<Callable&&, variant<Args...> &&, Tail && ...> apply_visitor(Callable && c, variant<Args...> && head, Tail && ... tail)
    noexcept( is_nothrow_visitable<Callable&&, variant<Args...> &&, Tail && ...>::value )
{
    return invoke(
        [&](auto && val)
        {
            return apply_visitor( std::forward<Callable>(c), std::move(val), std::forward<Tail>(tail) ... );
        },
        std::move(head).get_storage(),
        head.which() );
}

template<class Callable, class ... Args, class ... Tail>
result_of_visit_t<Callable&&, variant<Args...> const &, Tail && ...> apply_visitor(Callable && c, variant<Args...> const & head, Tail && ... tail)
    noexcept( is_nothrow_visitable<Callable&&, variant<Args...> const &, Tail && ...  >::value )
{
    return invoke(
        [&](auto & val)
        {
            return apply_visitor( std::forward<Callable>(c), val, std::forward<Tail>(tail) ... );
        },
        head.get_storage(),
        head.which() );
}

#endif // VISITOR_HPP
