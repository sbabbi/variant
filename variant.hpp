/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

#ifndef VARIANT_HPP
#define VARIANT_HPP

/**
 * @file
 * @author Ennio Barbaro
 * @date 18 Jan 2015
 * @brief Implements the class \ref variant
 */

#include <cassert>
#include <stdexcept>
#include <typeinfo>
#include <type_traits>
#include <utility>

#include "variant_storage.hpp"

/**
 * @brief A type safe generalized union
 * 
 * This class stores exactly one object of one of the type in \p Types.
 * Like <a href = http://www.boost.org/doc/libs/1_57_0>@c boost::variant </a>, 
 * this class provides the <em>never empty</em> guarantee.
 * 
 * Difference between this class and @c a href = http://www.boost.org/doc/libs/1_57_0>@c boost::variant </a>:
 *      1. Implementation of copy assignment (see \ref variant::operator=)
 *      2. This variant is never @c LessThanComparable, even if all the \p Types are.
 *         We believe that comparison on \ref variant might be confusing, and the user
 *         is still allowed to define its own comparison operators anyway
 * 
 * @tparam Types A list of types that can be stored in this variant.
 * @pre \p Types are all different.
 * @pre \p Types can not be references
 * @pre \p Types are not cv qualified
 */
template<class ... Types>
class variant;

/**
*  @brief Exception class thrown when a type that is not currently bound is accessed via \ref variant::get
*/
class bad_variant_access : public std::logic_error
{
public:
    explicit bad_variant_access(const std::string& arg) : logic_error(arg) { }
    explicit bad_variant_access(const char* arg) : logic_error(arg) { }

    virtual ~bad_variant_access() noexcept = default;
};

/**
 * @brief Defines the member type @c type to the @c Ith type of the \ref variant
 */
template<std::size_t I, class Variant>
struct variant_element;

/**
 * @brief Obtain the index of a variant type
 * 
 * Defines the member type @c type to be <tt>std::integral_constant\<std::size_t, I\></tt>,
 * where @c I is the index of the element in the variant
 */
template<class T, class Variant>
struct variant_index;

/**
 * @brief Provides access to the number of elements in a \ref variant as a compile-time constant expression.
 */
template<class Variant>
struct variant_size;

template<std::size_t I, class Variant>
using variant_element_t = typename variant_element<I, Variant>::type;

#ifndef VARIANT_IN_DOXYGEN_PARSING

template<std::size_t I, class Variant>
struct variant_element<I, const Variant>
{
    typedef typename std::add_const< typename variant_element<I, Variant>::type >::type type;
};
    
template<std::size_t I, class Variant>
struct variant_element<I, volatile Variant>
{
  typedef typename std::add_volatile< typename variant_element<I, Variant>::type >::type type;  
};
    
template<std::size_t I, class Variant>
struct variant_element<I, const volatile Variant>
{
    typedef typename std::add_cv< typename variant_element<I, Variant>::type >::type type;
};

template<std::size_t I, class Variant>
struct variant_element<I, Variant&>
{
    typedef typename std::add_lvalue_reference< typename variant_element<I, Variant>::type >::type type;
};
    
template<std::size_t I, class Variant>
struct variant_element<I, Variant&&>
{
    typedef typename std::add_rvalue_reference< typename variant_element<I, Variant>::type >::type type;
};
    
template<std::size_t I, class Head, class ... Args>
struct variant_element<I, variant<Head, Args ... > > :
    variant_element<I-1, variant<Args...> > {};

template<class Head, class ... Args>
struct variant_element<0, variant<Head, Args ... > >
{
    typedef Head type;
};

template<class T, class Variant>
struct variant_index<T, const Variant> : variant_index<T, Variant> {};

template<class T, class Variant>
struct variant_index<T, volatile Variant> : variant_index<T, Variant> {};

template<class T, class Variant>
struct variant_index<T, const volatile Variant> : variant_index<T, Variant> {};

template<class T, class Variant>
struct variant_index<T, Variant&> : variant_index<T, Variant> {};

template<class T, class Variant>
struct variant_index<T, Variant&&> : variant_index<T, Variant> {};

template<class T, class Head, class ... Args>
struct variant_index<T, variant<Head, Args... > > : 
    std::integral_constant<
        std::size_t,
        variant_index<T, variant<Args ...> >::value + 1
    > {};

template<class Head, class ... Args>
struct variant_index<Head, variant<Head, Args... > > : 
    std::integral_constant<
        std::size_t,
        0
    > {};

template<class ... Args>
struct variant_size< variant<Args...> > : std::integral_constant<std::size_t, sizeof ... (Args) > {};

template<class Variant>
struct variant_size< const Variant > : variant_size< Variant > {};

template<class Variant>
struct variant_size< volatile Variant > : variant_size< Variant > {};

template<class Variant>
struct variant_size< const volatile Variant > : variant_size< Variant > {};

template<class Variant>
struct variant_size< Variant& > : variant_size< Variant > {};

template<class Variant>
struct variant_size< Variant&& > : variant_size< Variant > {};

#endif //VARIANT_IN_DOXYGEN_PARSING

template<class ... Types>
class variant
{  
    template<class ...>
    struct deduce_overload_helper;
    
    template<class Head, class ... Tail>
    struct deduce_overload_helper<Head, Tail...> : deduce_overload_helper<Tail...>
    {
        using deduce_overload_helper<Tail...>::operator();
        
        std::integral_constant< std::size_t,
                                sizeof ... (Types) - sizeof ... (Tail) - 1> operator()( Head );
    };

    template<class Head>
    struct deduce_overload_helper<Head>
    {
        std::integral_constant< std::size_t, sizeof ... (Types) - 1> operator()( Head );
    };

    /**
     * @brief Trick to get the best matching overload.
     * 
     * Equivalent to the pseudo code:
     * \code{.cpp}
     *  struct X
     *  {
     *     int f(T0) { return 0; }
     *     int f(T1) { return 1; }
     *     int f(T2) { return 2; }
     *     ...
     *     int f(Tn) { return n;}
     *  };
     * \endcode
     * 
     * Where @c T0, @c T1, @c T2 .. @c Tn are the \ref Types of this variant.
     * Calling \ref deduce_overload \<T\> will return the index
     * of the type that best matches a construction with the argument \ref T,
     * or fail in case of ambiguity
     */
    template<class T, class X = void>
    struct deduce_overload
    {
        static_assert( std::conditional_t<true, std::false_type, X>::value, "Type deduction for T is ambiguous" );
    };
    
    template<class T>
    struct deduce_overload< 
        T,
        typename std::enable_if< 
            detail::or_< std::is_same< std::decay_t<T>,  Types > ... >::value
        >::type >
    {
        typedef typename variant_index< std::decay_t<T>, variant >::type type;
    };
    
    template<class T>
    struct deduce_overload< 
        T,
        typename std::enable_if< 
            !detail::or_< std::is_same< std::decay_t<T>,  Types > ... >::value,
            decltype(std::result_of_t< deduce_overload_helper<Types...>(T) >{}, void() )
        >::type >
    {
        typedef std::result_of_t< deduce_overload_helper<Types...>(T) > type;
    };
    
    template<class T>
    using deduce_overload_t = typename deduce_overload<T>::type;

    // Enable testing of deduce_overload
    friend class variant_deduce_overload_Test;

    // Checks if N types are all different
    template<class T, class ... Args>
    struct all_different :
            detail::and_<
                    all_different< Args ... >,
                    detail::not_< std::is_same<T,Args> >...
            > {};

    template<class T>
    struct all_different<T> : std::true_type {};

    template<class ... OtherTypes>
    static constexpr std::size_t get_which_for( const variant<OtherTypes...> & v) noexcept
    {
        constexpr std::size_t which_map[] = { deduce_overload_t<OtherTypes>::value ... };
        return which_map[ v.which() ];
    }

public:
    
    static_assert( all_different< Types ...>::value, "Variant type parameters must be all different" );
    static_assert( !detail::or_< std::is_reference<Types>... >::value, "Variant type parameters can not be references" );
    static_assert( !detail::or_< std::is_const<Types>... >::value, "Variant type parameters can not be const" );
    static_assert( !detail::or_< std::is_volatile<Types>... >::value, "Variant type parameters can not be volatile" );
    static_assert( sizeof ... (Types) > 0, "Type list can not be empty" );
    
    //! The underlying \ref variant_storage type.
    typedef variant_storage< Types ... > storage_t;

    /**
     * @brief Default construct this variant using the first type in \p Types.
     * 
     * Only available if the first type in the list of types is @c DefaultConstructible.
     */
    variant() noexcept( std::is_nothrow_constructible< storage_t, std::integral_constant<std::size_t, 0> >::value ) :
        which_(0),
        storage_( std::integral_constant<std::size_t, 0>{} )
    {}
 
    /**
     * @brief Copy constructor, invokes the copy constructor of the type currently bound on \p other.
     * @pre All \p Types must be copy constructible.
     * 
     * Copy construct the value currently bound on \p other on this variant.
     */
    variant( const variant& other ) 
        noexcept( detail::and_< std::is_nothrow_copy_constructible<Types> ... >::value ) :

        which_( other.which_ )
    {
        invoke(
            [&](auto & val)
            {
                typedef typename std::remove_reference<decltype(val)>::type T;

                new (& get< variant_index<T, variant>::value >(storage_)) T(val);
            },
            other.storage_,
            other.which_);
    }
    
    variant( variant & other )
        noexcept( detail::and_<std::is_nothrow_copy_constructible<Types> ... >::value ) :

        which_( other.which_ )
    {
        invoke(
            [&](auto & val)
            {
                typedef typename std::remove_reference<decltype(val)>::type T;

                new (& get< variant_index<T, variant>::value >(storage_)) T(val);
            },
            other.storage_,
            other.which_);
    }

    /**
     * @brief Move constructor, invokes the move constructor of the type currently bound on \p other.
     * @pre All \p Types must be @c MoveConstructible
     */
    variant( variant && other ) noexcept( detail::and_< std::is_nothrow_move_constructible<Types> ... >::value) :
        which_( other.which_ )
    {
        invoke(
            [&](auto & val)
            {
                typedef typename std::remove_reference<decltype(val)>::type T;
                
                new (& get< variant_index<T, variant>::value >(storage_)) T(std::move(val) );
            },
            other.storage_,
            other.which_);
    }

    /**
     * @brief Copy from a compatible variant.
     * @pre \p OtherTypes Must be a subset of \p Types
     */
    template<class ... OtherTypes>
    variant( const variant<OtherTypes...> & other ) 
        noexcept( detail::and_<std::is_nothrow_copy_constructible<OtherTypes> ... >::value ) :

        which_( get_which_for(other) )
    {
        invoke(
            [&](auto & val)
            {
                typedef typename std::remove_reference<decltype(val)>::type T;

                new (& get< deduce_overload_t<T>::value >(storage_)) T(val);
            },
            other.get_storage(),
            other.which());
    }
    
    /**
     * @brief Move from a compatible variant.
     * @pre \p OtherTypes Must be a subset of \p Types
     */
    template<class ... OtherTypes>
    variant( variant<OtherTypes...> && other ) 
        noexcept( detail::and_<std::is_nothrow_move_constructible<OtherTypes> ... >::value ) :

        which_( get_which_for(other) )
    {
        invoke(
            [&](auto && val)
            {
                typedef typename std::remove_reference<decltype(val)>::type T;

                new (& get< deduce_overload_t<T>::value >(storage_)) T(std::move(val));
            },
            other.get_storage(),
            other.which());
    }
    
    /**
     * @brief Generic constructor, tries to deduce the desired type.
     * 
     * Use the same rules as overload resolution to determine which type in \p Types
     * shall be initialized, then perfect forward the argument to the constructor of that type.
     */
    template<class T>
    variant( T && value ) 
        noexcept( std::is_nothrow_constructible<
            storage_t,
            deduce_overload_t<T&&>,
            T&&>::value) : 

        which_( deduce_overload_t<T&&>::value ),
        storage_( deduce_overload_t<T&&>{}, 
                  std::forward<T>(value) )
    {}
    
    /**
     * @brief Initializer list constructor, tries to deduce the desired type
     * 
     * Use the same rules as overload resolution to determine which type in \p Types
     * shall be initialized, then perfect forward the arguments to the constructor of that type.
     */
    template<class T>
    variant( std::initializer_list<T> init_list ) 
        noexcept( std::is_nothrow_constructible<
            storage_t,
            deduce_overload_t< std::initializer_list<T> >,
            std::initializer_list<T> >::value) : 

        which_( deduce_overload_t< std::initializer_list<T> >::value ),
        storage_( deduce_overload_t< std::initializer_list<T> >{}, init_list )
    {}

    /**
     * @brief Destructor, calls the destructor on the currently bound type.
     * @pre All \p Types must be @c Destructible
     */
    ~variant() noexcept( detail::and_< std::is_nothrow_destructible< Types > ... >::value)
    {
        invoke(
            [&](auto & val)
            {
                typedef typename std::remove_reference<decltype(val)>::type T;
                val.~T();
            },
            storage_,
            which_);
    }
    
    /**
     * @brief Copy assignment operator.
     * @pre All \p Types must be @c CopyAssignable.
     * @pre All \p Types must be @c NothrowDestructible.
     * @pre Either all \p Types are @c NothrowCopyConstructible or all \p Types are @c NothrowMoveConstructible
     * 
     * If <tt>\ref which() == \p other.which()</tt> calls the copy assignemnt on the bound type.
     * 
     * Otherwise, if the type currently bound on \p other is @c NothrowCopyConstructible destroy the current bound object and 
     * reinitialize the variant using a copy of the object currently bound on \p other.
     * 
     * If the type currently bound on \p other is not @c NothrowCopyConstructible, performs a temporary copy of \p other, then
     * destroy the current bound object and move the temporary copy into this.
     */
    variant& operator=(const variant & other) 
        noexcept( detail::and_ <
            std::is_nothrow_copy_assignable< Types > ...,
            std::is_nothrow_copy_constructible< Types > ... >::value)
    {
        static_assert( detail::and_< std::is_nothrow_destructible<Types> ... >::value, 
                      "Can not implement any exception safety on variant copy assignement if a destructor can throw" );

        if ( which_ == other.which_ )
        {
            invoke(
                [&](auto & val)
                {
                    typedef typename std::remove_reference<decltype(val)>::type T;

                    get< variant_index<T, variant>::value >( storage_ ) = val;
                },
                other.storage_,
                other.which_ );
        }
        else
        {
            constexpr bool is_nothrow_copy_constructible[] = { std::is_nothrow_copy_constructible<Types>::value ...  };

            if ( is_nothrow_copy_constructible[ other.which_ ] )
            {
                // Default strategy, nothrow copy constructor, nothing can go wrong.
                // Just destroy the old one and construct a new one
                ~variant();
                
                new (this) variant( other );
            }
            else
            {
                // If the move constructor throws, we can not restore the original value
                static_assert( detail::and_< std::is_nothrow_move_constructible<Types> ... >::value, 
                        "Can not implement any exception safety on variant copy assignement if a move constructor can throw" );
                
                // Copy and move
                variant temp( other ); //Even if it throws, strong guarantee
                
                // Destroy the old one
                this->~variant();
                
                // Reinitialize
                new (this) variant( std::move(other) );
            }
        }
        return *this;
    }

    /**
     * @brief Move assignment operator.
     * @pre All \p Types must be @c MoveAssignable.
     * @pre All \p Types must be @c NothrowDestructible.
     * @pre All \p Types are @c NothrowMoveConstructible
     * 
     * If <tt>\ref which() == \p other.which()</tt> calls the move assignemnt on the bound type.
     * 
     * Otherwise, destroy the current bound object and reinitialize the variant moving the object currently bound on \p other.
     */
    variant& operator=(variant && other) noexcept( detail::and_ <std::is_nothrow_move_assignable<Types > ... >::value)
    {
        if ( which_ == other.which_ )
        {
            invoke(
                [&](auto & val)
                {
                    typedef typename std::remove_reference<decltype(val)>::type T;

                    get< variant_index<T, variant>::value >( storage_ ) = std::move(val);
                },
                other.storage_,
                other.which_ );
        }
        else
        {
            // If the move constructor throws, we can not restore the original value
            static_assert( detail::and_< std::is_nothrow_move_constructible<Types > ... >::value, 
                           "Can not implement any exception safety on variant move assignement if a move constructor can throw" );

            static_assert( detail::and_< std::is_nothrow_destructible<Types > ... >::value, 
                           "Can not implement any exception safety on variant move assignement if a destructor can throw" );            
            
            // Destroy the old one
            this->~variant();
            
            // Move in
            new (this) variant( std::move(other) );
        }
        return *this;
    }

    /**
     * @brief Return the index of the current bound object.
     */
    std::size_t which() const noexcept { return which_; }

    /**
     * @brief Return the type_info of the current bound object.
     */
    const std::type_info & type() const noexcept
    {
        return invoke(
            [&](auto & val) -> const std::type_info &
            {
                return typeid(typename std::remove_reference<decltype(val)>::type);
            },
            storage_,
            which_);
    }
    
    /**
     * @brief Return a reference to the current bound object.
     * @tparam T The expected type of the object.
     * @pre which() == \ref variant_index \<T, variant\>::value
     * @throw bad_variant_access If the precondition is not met.
     */
    template<class T, class Variant, class = typename 
        std::enable_if<
            std::is_same< variant, typename std::decay< Variant >::type >::value
        >::type >
    friend variant_element_t< variant_index<T, Variant>::value, Variant > get(Variant && v)
    {
        if ( v.which() != variant_index<T, variant>::value )
            throw bad_variant_access("bad_variant_access");
        return get< variant_index<T, variant>::value >(std::forward<Variant>(v).storage_);
    }
    
    storage_t& get_storage() & noexcept { return storage_; }
    storage_t&& get_storage() && noexcept { return std::move(storage_); }
    const storage_t& get_storage() const & noexcept { return storage_; }
    
private:
    std::size_t which_;
    storage_t storage_;
};


#endif //VARIANT_HPP
