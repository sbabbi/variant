/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

#ifndef VARIANT_STORAGE_HPP
#define VARIANT_STORAGE_HPP

/**
 * @file
 * @author Ennio Barbaro
 * @date 18 Jan 2015
 * @brief Implements the class \ref variant_storage
 */

#include <cassert>
#include <type_traits>
#include <utility>

#include "relational.hpp"

/**
 * @brief A templated generalized union
 * @warning The user must manually call the destructor of the active member
 * 
 * Represents the storage for a variant. 
 * Use a generalized union to automatically take care of alignment issues.
 * 
 * Provides a free function @c get to obtain the i-th element, acts like <tt>std::get(tuple)</tt>.
 * Notice that this class is very limited by its own nature, it can not support
 * direct asssignment (only assignment to a specific sub element). It supports
 * in place construction, by passing a @c std::integral_constant tag to specify the actual type that
 * the user wants to construct.
 * 
 * For maximum genericity, having the same type multiple times in the parameter list is allowed,
 * but the user has still to take care to access the type through the same index.
 * 
 * This class is meant to be used only by \ref variant, users must be extremely careful to use
 * this class copy constructor, assignment operator and destructor.
 */
template<class ... Args>
class variant_storage;

template<class ... Args>
union literal_variant_storage;

template<class ... Args>
union nonliteral_variant_storage;

/**
 * @brief Defines the member type @c type to the @c I-th type of the \ref variant_storage
 */
template<std::size_t I, class VariantStorage>
struct variant_storage_element;

/**
 * @brief Provides access to the number of elements in a \ref variant_storage as a compile-time constant expression.
 */
template<class VariantStorage>
struct variant_storage_size;

#ifndef VARIANT_IN_DOXYGEN_PARSING

template<std::size_t I, class VariantStorage>
struct variant_storage_element<I, const VariantStorage> : 
    std::add_const< typename variant_storage_element<I, VariantStorage>::type >::type {};
    
template<std::size_t I, class VariantStorage>
struct variant_storage_element<I, volatile VariantStorage> : 
    std::add_volatile< typename variant_storage_element<I, VariantStorage>::type >::type {};
    
template<std::size_t I, class VariantStorage>
struct variant_storage_element<I, const volatile VariantStorage> : 
    std::add_cv< typename variant_storage_element<I, VariantStorage>::type >::type {};

template<std::size_t I, class VariantStorage>
using variant_storage_element_t = typename variant_storage_element<I, VariantStorage>::type;

template<std::size_t I, class Head, class ... Args>
struct variant_storage_element<I, variant_storage<Head, Args ... > >
{
    typedef typename variant_storage_element<I-1, variant_storage<Args... > >::type type;
};

template<class Head, class ... Args>
struct variant_storage_element<0, variant_storage<Head, Args ... > >
{
    typedef Head type;
};


template<class ... Args>
struct variant_storage_size< variant_storage<Args...> > : std::integral_constant<std::size_t, sizeof ... (Args) > {};

template<class ... Args>
struct variant_storage_size< const variant_storage<Args...> > : std::integral_constant<std::size_t, sizeof ... (Args) > {};

template<class ... Args>
struct variant_storage_size< volatile variant_storage<Args...> > : std::integral_constant<std::size_t, sizeof ... (Args) > {};

template<class ... Args>
struct variant_storage_size< const volatile variant_storage<Args...> > : std::integral_constant<std::size_t, sizeof ... (Args) > {};

#endif //VARIANT_IN_DOXYGEN_PARSING

template<class ... Args>
union literal_variant_storage;

template<class Head, class ... Tail>
union literal_variant_storage<Head, Tail...>
{
    constexpr literal_variant_storage()  noexcept : empty{} {}

    template<std::size_t I, class ... Args>
    constexpr literal_variant_storage( std::integral_constant<std::size_t, I>, Args && ... args)
        noexcept( std::is_nothrow_constructible< 
            literal_variant_storage<Tail...>,
            std::integral_constant<std::size_t, I-1>,
            Args && ... >::value ) :
        
        tail( std::integral_constant<std::size_t, I-1>{},
              std::forward<Args>(args) ... )
    {}
    
    template<class ... Args>
    constexpr literal_variant_storage( std::integral_constant<std::size_t, 0>, Args && ... args)
        noexcept( std::is_nothrow_constructible< Head, Args && ... >::value ) :

        head( std::forward<Args>(args) ... )
    {}
    
    template<std::size_t I>
    constexpr variant_storage_element_t<I, variant_storage<Head, Tail...>> & get( std::integral_constant<std::size_t, I> ) & noexcept
    {
        return tail.get( std::integral_constant<std::size_t, I-1>() );
    }
    
    constexpr Head& get( std::integral_constant<std::size_t, 0> ) & noexcept
    {
        return head;
    }
        
    template<std::size_t I>
    constexpr variant_storage_element_t<I, variant_storage<Head, Tail...>> && get( std::integral_constant<std::size_t, I> ) && noexcept
    {
        return std::move(tail).get( std::integral_constant<std::size_t, I-1>() );
    }
    
    constexpr Head&& get( std::integral_constant<std::size_t, 0> ) && noexcept
    {
        return std::move(head);
    }
        
    template<std::size_t I>
    constexpr variant_storage_element_t<I, variant_storage<Head, Tail...>> const & get( std::integral_constant<std::size_t, I> ) const & noexcept 
    {
        return tail.get( std::integral_constant<std::size_t, I-1>() );
    }
    
    constexpr const Head& get( std::integral_constant<std::size_t, 0> ) const & noexcept
    {
        return head;
    }

private:
    char empty;
    Head head;
    literal_variant_storage<Tail ... > tail;
};

template<>
union literal_variant_storage<>
{
};

template<class ... Args>
union nonliteral_variant_storage;

template<class Head, class ... Tail>
union nonliteral_variant_storage<Head, Tail...>
{
    nonliteral_variant_storage() noexcept : empty{} {}

    template<std::size_t I, class ... Args>
    nonliteral_variant_storage( std::integral_constant<std::size_t, I>, Args && ... args)
        noexcept( std::is_nothrow_constructible< 
            nonliteral_variant_storage<Tail ... >,
            std::integral_constant<std::size_t, I-1>,
            Args && ... >::value ) :
        
        tail( std::integral_constant<std::size_t, I-1>{},
              std::forward<Args>(args) ... )
    {}
    
    template<class ... Args>
    nonliteral_variant_storage( std::integral_constant<std::size_t, 0>, Args && ... args)
        noexcept( std::is_nothrow_constructible< Head, Args && ... >::value ) :

        head( std::forward<Args>(args) ... )
    {}
    
    ~nonliteral_variant_storage() {}
    
    template<std::size_t I>
    variant_storage_element_t<I, variant_storage<Head, Tail...>> & get( std::integral_constant<std::size_t, I> ) & noexcept
    {
        return tail.get( std::integral_constant<std::size_t, I-1>() );
    }
    
    Head& get( std::integral_constant<std::size_t, 0> ) & noexcept
    {
        return head;
    }
        
    template<std::size_t I>
    variant_storage_element_t<I, variant_storage<Head, Tail...>> && get( std::integral_constant<std::size_t, I> ) && noexcept
    {
        return std::move(tail).get( std::integral_constant<std::size_t, I-1>() );
    }
    
    Head&& get( std::integral_constant<std::size_t, 0> ) && noexcept
    {
        return std::move(head);
    }
        
    template<std::size_t I>
    variant_storage_element_t<I, variant_storage<Head, Tail...>> const & get( std::integral_constant<std::size_t, I> ) const & noexcept 
    {
        return tail.get( std::integral_constant<std::size_t, I-1>() );
    }
    
    const Head& get( std::integral_constant<std::size_t, 0> ) const & noexcept
    {
        return head;
    }

private:
    char empty;
    Head head;
    nonliteral_variant_storage<Tail ... > tail;
};

template<>
union nonliteral_variant_storage<>
{
};

template<class ... Args>
class variant_storage
{
    using storage_type = typename std::conditional<
            detail::and_< std::is_literal_type<Args> ... >::value,
            literal_variant_storage<Args...>,
            nonliteral_variant_storage<Args...>
        >::type;

public:
    constexpr variant_storage()  noexcept(std::is_nothrow_constructible<storage_type>::value) : value{} {}

    template<std::size_t I, class ... CArgs>
    constexpr variant_storage( std::integral_constant<std::size_t, I>, CArgs && ... args )
        noexcept( std::is_nothrow_constructible< storage_type, std::integral_constant<std::size_t, I>, CArgs && ... >::value ) :

        value( std::integral_constant<std::size_t, I>{}, std::forward<CArgs>(args) ... )
    {}
    
    template<std::size_t I, class ... OtherArgs>
    constexpr friend variant_storage_element_t<I, variant_storage<OtherArgs...> > & get(variant_storage<OtherArgs...> & v) noexcept;
    
    template<std::size_t I, class ... OtherArgs>
    constexpr friend variant_storage_element_t<I, variant_storage<OtherArgs...> > && get(variant_storage<OtherArgs...> && v) noexcept;
    
    template<std::size_t I, class ... OtherArgs>
    constexpr friend variant_storage_element_t<I, variant_storage<OtherArgs...> > const & get(variant_storage<OtherArgs...> const & v) noexcept;
    
private:
    storage_type value;
};

template<std::size_t I, class ... Args>
constexpr variant_storage_element_t<I, variant_storage<Args...> > & get(variant_storage<Args...> & v) noexcept
{
    return v.value.get( std::integral_constant<std::size_t, I>() );
}

template<std::size_t I, class ... Args>
constexpr variant_storage_element_t<I, variant_storage<Args...> > && get(variant_storage<Args...> && v)  noexcept
{
    return std::move(v.value).get( std::integral_constant<std::size_t, I>() );
}

template<std::size_t I, class ... Args>
constexpr variant_storage_element_t<I, variant_storage<Args...> > const & get(variant_storage<Args...> const & v) noexcept
{
    return v.value.get( std::integral_constant<std::size_t, I>() );
}

class invoke_variant_storage_t
{
    template<std::size_t I, class Callable, class VariantStorage>
    static decltype(auto) invoke( Callable && c,
                                  VariantStorage && v,
                                  std::size_t which,
                                  std::integral_constant<std::size_t, I> ) 
    {
        assert( which < I );
        return which == (I-1) ? 
            std::forward<Callable>(c)( get<I-1>(std::forward<VariantStorage>(v)) ) :
            invoke( std::forward<Callable>(c),
                    std::forward<VariantStorage>(v),
                    which, 
                    std::integral_constant<std::size_t, I-1>{} );
    }
    
    template<class Callable, class VariantStorage>
    static decltype(auto) invoke( Callable && c, VariantStorage && v, std::size_t which, std::integral_constant<std::size_t, 1> )
    {
        assert( which == 0 );
        return std::forward<Callable>(c)( get<0>(std::forward<VariantStorage>(v)) );
    }

    template<class Callable, 
             class VariantStorage,
             class Indices = 
                std::make_integer_sequence<
                    std::size_t,
                    variant_storage_size< std::remove_reference_t<VariantStorage> >::value 
                > 
            >
    struct is_nothrow_callable;
    
    template<class Callable, class VariantStorage, std::size_t ... Is>
    struct is_nothrow_callable< Callable, VariantStorage, std::integer_sequence<std::size_t, Is...> > : 
        detail::and_<
            std::integral_constant<
                bool,
                noexcept( std::declval<Callable&&>()( get<Is>(std::declval<VariantStorage>()) ) ) > ...
            > {};
    
public:
    constexpr invoke_variant_storage_t() noexcept {}

    template<class VariantStorage, class Callable>
    decltype(auto) operator()( Callable && c, VariantStorage && v, std::size_t which ) const
        noexcept( is_nothrow_callable< Callable &&, VariantStorage && >::value )
    {
        return invoke( std::forward<Callable>(c),
                       std::forward<VariantStorage>(v),
                       which,
                       typename variant_storage_size<
                            typename std::remove_reference<VariantStorage>::type
                        >::type {} );
    }
};

/**
 * @brief Calls the provided \p Callable with an element of the supplied variant storage
 * @tparam Callable A model of @c UnaryFunction.
 * @param c a \p Callable object, that provides a set of overloaded <tt>operator()</tt> that can accept any type in the storage
 * @param v a \ref variant_storage
 * @param which The index used to interpret the value in the storage
 */
template<class VariantStorage, class Callable>
decltype(auto) invoke( Callable && c, VariantStorage && v, std::size_t which )
    noexcept( 
        noexcept(
            invoke_variant_storage_t{}( 
                std::forward<Callable>(c),
                std::forward<VariantStorage>(v), 
                which
        ) ) )
{
    return invoke_variant_storage_t{}( 
                std::forward<Callable>(c),
                std::forward<VariantStorage>(v), 
                which);
}

#endif // VARIANT_STORAGE_HPP
